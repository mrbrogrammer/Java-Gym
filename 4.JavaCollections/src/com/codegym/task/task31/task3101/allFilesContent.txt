taskKey="com.codegym.task.task31.task3101"\n\nIterating through a file tree


1. The main method is passed two arguments as inputs.
The first argument is path, which is the path to the directory; the second is resultFileAbsolutePath, which is the name (full path) of an existing file that will store the result.
2. For each file in the path directory and in all of its subdirectories, do the following:
For each file whose size in bytes is NOT greater than 50, do the following:
2.1. Rename resultFileAbsolutePath to &quot;allFilesContent.txt&quot; (use the FileUtils.renameFile method and FileUtils.isExist if necessary).
2.2. Sequentially write the contents of each file from step 2.1 to allFilesContent.txt. After the body of each file, write &quot;\n&quot;.
All files have the TXT extension.
Use &quot;/&quot; as the path separator.


Ð¢ÑÐµÐ±Ð¾Ð²Ð°Ð½Ð¸Ñ:
1.	The file passed as the second argument to main must be renamed to allFilesContent.txt.
2.	You need to create a stream to write to the renamed file.
3.	The contents of every file that is 50 bytes or smaller must be written to the allFilesContent.txt file.
4.	The output stream to the file must be closed.
5.	Don&#39;t use static variables.



package com.codegym.task.task31.task3101;

import java.io.File;

public class FileUtils {

    public static void deleteFile(File file) {
        if (!file.delete()) System.out.println("Cannot delete file " + file.getName());
    }

    public static void renameFile(File source, File destination) {
        if (!source.renameTo(destination)) System.out.println("Cannot rename file " + source.getName());
    }

    public static boolean isExist(File file) {
        return file.exists();
    }
}
package com.codegym.task.task31.task3101;

/* 
Iterating through a file tree

*/
import java.io.*;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

public class Solution {
    public static void main(String[] args) throws IOException {
        File folder = new File(args[0]);
        
        List<File> filesWithSizeLessThan50 = Arrays.stream(Objects.requireNonNull(folder.listFiles()))
                .filter(x -> (byte) x.length() < 50)
                .sorted(Comparator.comparing(File::getName))
                .collect(Collectors.toList());
        
        // getting the correct file by checking whether the list contains it, then rename the file to a different name.
        List<File> fileWithSpecialName = filesWithSizeLessThan50.stream()
                .filter(x -> x.getName().equals("resultFileAbsolutePath"))
                .filter(FileUtils::isExist).collect(Collectors.toList());
                
        List<File> result = filesWithSizeLessThan50.stream()
                .filter(x -> !x.getName().equals("resultFileAbsolutePath"))
                .collect(Collectors.toList());
    
        try {
            FileUtils.renameFile(fileWithSpecialName.get(0), new File(args[0] + "allFilesContent.txt"));
        } catch (Exception e) {
            e.printStackTrace();
        }
    
        StringBuilder string = new StringBuilder();
        for (File file : result) {
            
            FileInputStream inStream = null;
            try {
                inStream = new FileInputStream(file);
                while (inStream.available() > 0) {
                    char c = (char) inStream.read();
                    string.append(c);
                    
                }
                string.append('\n');

            } catch (FileNotFoundException e) {
                throw new RuntimeException(e + " file is missing: " + file.getName());
            } finally {
                assert inStream != null;
                inStream.close();
            }
        }
        
        FileOutputStream outStream;
        try {
            
            File f = new File(args[0] + "allFilesContent.txt");
            outStream = new FileOutputStream(f.getAbsolutePath());
        
            outStream.write(string.toString().getBytes());
            outStream.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
    }
}

